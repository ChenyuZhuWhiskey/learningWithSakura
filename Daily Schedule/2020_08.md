# 20200724-20200809

这段时间就是在完成CSAPP LAB，因为比较忙也没有做daily record：

 https://github.com/ChenyuZhuWhiskey/Csapp-Lab 

到现在为止做完了data，bomb，attack，buffer，arch，cache，perform，还差shell，malloc，proxy，争取下周做完

# 20200810

看CSAPP的第八章，这是做shell lab(写一个linux shell)的前置条件。

这一章是从异常开始讲起的，并且指出了unix系统通过异常来实现system call(trap)。当用户想要和内核交互时，内核在执行system call的时候就会生成一个陷阱处理程序，当程序完成后回到原来的控制流。异常一部分是由应硬件实现，一部分是由软件实现。比如x86-64架构上定义了250种异常，前31种是硬件架构师规定的，后面的是操作系统内核规定的。

进程就是一个基于异常的构造块，进程为程序提供了一层抽象：

- 程序拥有一个独立的逻辑控制流，独自占用硬件资源的假象
- 私有地址空间，独自占用内存资源的假象

实际上操作系统上的进程是交错使用计算机硬件资源的，一个进程使用资源时，其它进程会被挂起，并保存上下文。而操作系统就是通过上下文切换这一异常实现这一过程的：

- 进程A运行，用户模式
- 上下文切换，进入内核模式
- 进程B运行，用户模式
- 上下文切换
- ...

上下文切换在内核模式下运行（拥有所有资源的读写权限）：

- 保存进程上下文
- 恢复被抢占进程的上下文
- 控制传递给新的进程

要注意，进程之间如果是并发的，那么假如进程间共享了数据和代码（父进程和子进程），那么结果可能会因为进程竞争而导致不唯一的结果。

`c`为进程创建的system call封装了`fork()`函数：

- `fork()`函数会创新新的子进程，父进程返回值为进程的pid，如果是在子进程中，`fork()`会返回0

`fork()`可以创建进程，但子进程运行结束后不会自动释放占用的资源，成为僵尸进程，为了回收这些进程，我们需要信号的参与。

所谓的信号也是一种异常，但它是操作系统在进程层面的高级异常，当信号被发送到某个进程后，操作系统内核就会强迫进程做对应信号的异常处理程序作为信号接收的成果。

我们可以自己通过`signal()`函数定义相应的信号处理程序：

```c
#include<signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum,sighandler_t handler);
```

`signal()`会接受自定义信号处理程序的函数指针，然后在进程接受到信号后调用这个函数，返回这个函数指针。

实际上，每个子进程结束后都会给父进程发送`SIGCHILD`信号让父进程知道进程结束，只是默认的信号处理函数什么都不做，如果通过`signal()`重写调用信号处理程序，就能通过`waitpid()`函数回收子进程，`waitpid(pid_t pid, int* status, int options)`会做下面的事情：

- 阻塞父进程，等待子进程退出
- 回收子进程的残留资源
- 获取子进程的结束状态(status)

# 20200811

今天写完shell lab，然后开始看CSAPP的第9章虚拟内存，开了个头。

虚拟内存实际上给了用户一个单个进程在独自使用全部物理内存的假象，比如一个64位系统中，一个程序总是有64位的地址空间，并且代码段总是从地址0x400000开始，这样就简化了编译器的链接过程和指令的寻址过程。

本质上，虚拟内存也是通过硬件和软件共同实现的，CPU上集成了一个内存管理单元，将CPU指令中的虚拟地址空间映射到了实际的物理空间。

# 20200812-20200831

lab除了proxy都写完了，在malloc lab里多花了一点时间，因为去读了glibc malloc的源代码，写了博客： [https://chenyuzhuwhiskey.github.io/2020/08/14/glibc-malloc-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/](https://chenyuzhuwhiskey.github.io/2020/08/14/glibc-malloc-源码分析/) ，proxy准备学计算机网络的时候回来看



